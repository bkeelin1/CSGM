#' @title lolligen: An Interactive Principal Component Analysis Visualization Tool
#'
#' @description
#' This function takes a principal component analysis (PCA) object via the
#' internal function pca_variances and generates several interactive visual aids
#' commonly required to analyze interindividual and multivariate variance in PCA.
#' This function primarily uses the **plotly** package to generate interactive
#' PCA plots between principal components as well as interactive lollipop graphs
#' showing the extreme shape variances for each meaningful principal component.
#'
#' @param Data_PCA a list object resembling or formed by the *pca_variances* function output.
#'
#' @param k an integer indicating the number of dimensions in the landmark configuration
#' prior to data transformation via PCA. k = 1 is for non-landmark data. Default value is 3.
#'
#' @param PCA_var an object from the *pca_variances* function output.
#'
#' @param ID a vector containing the identification names and/or numbers for each
#' observation from the principal component analysis.
#'
#' @param coord_name a vector listing the names of the landmark coordinates.
#'
#' @param Group a list object containing one or more grouping variable vectors.
#'
#' @param no.shape a boolean value indicating whether the function should
#' estimate and save the shape extremes of each important principal component.
#' Default value is set to FALSE. If set to TRUE, the function will not generate
#' interactive plots to visualize landmark variance based on each principal component.
#'
#' @param subset an optional vector listing a grouping variable for each landmark.
#' If subset is added and no.shape is set to FALSE, the landmark lollipop graph
#' will segment each of the landmarks by the subset grouping, allowing the user
#' to show and hide groups of landmarks to visualize specific shape variances.
#'
#' @details
#' This function requires a list object generated by the *gm.prcomp* function in
#' the *geomorph* package, or a list containing the same variables (i.e., principal
#' component scores, eigenvalues and eigenvectors, number of interested principal components,
#' number of dimensions). The function then uses the argument *PCA_var*, an output
#' from the *pca_variances* function, and generates automatically labeled,
#' interactive principal component plots that can be used to analyze
#' interindividual variation and also evaluate variable relationships through lollipop
#' graphs of the variables used to conduct the PCA. This function will accept
#' any list object for Data_PCA as long as it contains the following objects:
#' \itemize{
#'    \item *x*:   a data table of the principal component scores (columns) and observations (rows)
#'    \item *sdev*:  a data table containing the eigenvalues from the PCA.
#'    \item *rotation*:  a data table containing the rotation matrix or eigenvectors
#'    calculated during the PCA.
#'    \item *center*:  a 2D or 3D p x k x n array containing the mean variable configuration
#' }
#' Additionally, lolligen allows a list object containing vectors of group labels
#' for each observation in the landmark configuration. This function does not
#' conduct a between group PCA. If this is desired, Data_PCA should contain the values
#' output by a between groups PCA such as the *bgPCA* function from the **ade4** package.
#' From the data presented in Data_PCA, the function will generate convex hulls and color
#' the individuals by each grouping variable in the list and store each plot separately.
#'
#' @returns a list object containing the following:
#'
#' \itemize{
#'    \item *PCA_list*:  a list object containing all possible principal component plot pairs.
#'    \item *PC_mean_max_min*:   a list object containing the mean, maximum extreme,
#'    and minimum extreme shapes or combination of variables respectively for each
#'    meaningful principal component.
#'    \item *lollipop_PCs*:  a list containing a series of lollipop graph plots
#'    for each PC. Each plot already contains the mean, maximum, and minimum shape
#'    extremes to visualize the shape variations across each principal component.
#'    Keep in mind that double brackets are required to call each PC (see examples).
#'    \item *PCA_Group*:   an optional list object containing the names of each grouping
#'    variable supplied through the Group argument. If NULL, this object will
#'    not be generated. If argument Group is not NULL, a convex hull plot will be
#'    generated for each principal component pairing for each group vector in the list.
#' }
#'
#' @author
#' Brian Anthony Keeling
#'
#' @seealso \code{plotly} \code{hullgen}
#'
#' @importFrom plotly plot_ly add_trace layout
#' @importFrom geomorph arrayspecs
#' @importFrom grDevices png dev.off
#' @importFrom RColorBrewer brewer.pal
#' @importFrom dplyr filter
#' @importFrom ggplot2 ggplot aes geom_boxplot stat_summary theme element_text
#' @importFrom ggpubr theme_pubclean ggarrange annotate_figure text_grob
#'
#' @export
#'
#' @examples
#'
#' \dontrun{
#'
#' # Example 1: Without groupings or subsets
#'
#' # Import the sample 3D p x k x n array *Corpus_Land*
#' data(Corpus_Land)
#'
#' # Conduct a Principal Component Analysis on the 3D array using *gm.prcomp* from **geomorph**
#' Data_PCA = gm.prcomp(Corpus_Land)
#'
#' # Summarize the results with the pca_variances function
#' PCA_var = pca_variances(Data_PCA) # input object from the PCA
#'
#' # View the scree plot
#' PCA_var$Scree
#'
#' # View the number of meaningful PCs
#' PCA_var$PCs
#'
#' # Conduct the lolligen function and input the number of desired principal components.
#'
#' output <- lolligen(Data_PCA, # PCA object
#'                    k = 3, # three dimensional landmark data
#'                    PCA_var # output from the internal pca_variances function
#'                    )
#'
#' # Visualize individual variation between principal components 1 and 2
#' output$PCA_list$PC_1_2
#'
#' # Visualize
#'
#' # Visualize shape changes along PC 1
#'
#' output$lollipop_PCs[[1]]
#'
#' # Visualize shape changes along PC 2
#'
#' output$lollipop_PCs[[2]]
#'
#' # Save the plot
#'
#' saveWidget(output$lollipop_PCs[[1]], "PC_1_Shape_Changes.html")
#'
#' # Example 2: lolligen with groupings and subsetted landmarks
#'
#' # Import the sample dataset Corpus_Land
#' data(Corpus_Land)
#'
#' # Import the associated sample Biomechanical data for IDs and grouping variables.
#' data(Biomechanics)[1:119,1:3] # we are only interested in the groupings.
#'
#' # Conduct a Principal Component Analysis on the 3D array.
#' Data_PCA = gm.prcomp(Corpus_Land)
#'
#' # Summarize the results with the pca_variances function
#' PCA_var = pca_variances(Data_PCA) # input object from the PCA
#'
#' # Create a list containing randomized Grouping variables
#'
#' Group = list(Collection = Biomechanics$Collection)
#' ID = unique(Biomechanics$ID)
#'
#' # Conduct the lolligen function and input the number of desired principal components.
#'
#' output <- lolligen(Data_PCA, # PCA object
#'                    k = 3, # three dimensional landmark data
#'                    PCA_var, # output from the internal pca_variances function
#'                    ID = ID, # specimen IDs
#'                    coord_name = dimnames(Corpus_Land)[[[1]]], # landmark names
#'                    Group = Group, # list of grouping variables
#'                    no.shape = FALSE, # no mesh generation is required
#'                    subset = c(rep("LM1M2", "LP3P4", "Symphysis", "RP3P4", "RM1M2"), each = 120)
#'                    )
#'
#' # Visualize individual variation between principal components 1 and 2
#' output$PCA_list$PC_1_2
#'
#' # Visualize grouped PCA plot between principal components 1 and 2
#'
#' output$PCA_Group$Collection$PC_1_2
#'
#' # Visualize shape changes along PC 1
#'
#' output$lollipop_PCs[[1]]
#'
#' # Visualize shape changes along PC 2
#'
#' output$lollipop_PCs[[2]]
#'
#' }

lolligen <- function(Data_PCA,
                     k = 3,
                     PCA_var = NULL,
                     ID = NULL,
                     coord_name = NULL,
                     Group = NULL,
                     no.shape = FALSE,
                     subset = NULL) {

  lollipops = list()

  if(is.null(PCA_var)) {
    PCA_var = PCA_variances(Data_PCA)
    Data_PCA = PCA_var$PCA_Data
    PCs = as.numeric(PCA_var$PCs)
    PCA_var = data.frame(PCA_var$PCA_var)
  } else {
    PCs = as.numeric(PCA_var$PCs)
    Data_PCA = PCA_var$PCA_Data
    PCA_var = data.frame(PCA_var$PCA_var)
  }

  if(as.numeric(PCs) <= 2) {
    PCs = 2
  }

  if (is.null(ID)) {
    ID <- c(rep(1:nrow(Data_PCA$x)))
  }

  if (is.null(coord_name)) {
    if(is.character(rownames(Data_PCA$rotation))){
      coord_name = rownames(Data_PCA$rotation)
    } else {
      n_point = length(Data_PCA$center) / k
      coord_name = as.character(rep(1:n_point))
    }
  }
  if(!is.null(Group)) {
    if(!"list" %in% class(Group)) {
      placeholder = list()
      if(!is.null(ncol(Group))){
        if(ncol(Group) > 1) {
          for(g in 1:ncol(Group)) {
            placeholder[[g]] <- Group[,g]
            placeholder[[g]] <- placeholder[[g]][[1]]
            names(placeholder)[g] <- colnames(Group[,g])
          }
          Group <- placeholder
        }
      } else {
        placeholder = list()
        placeholder[[1]] <- Group
        names(placeholder) <- "Group"
        Group = placeholder
      }
    }
  }

  generate_pc_sets <- function(n_pcs) { # helper function to automate pc plots
    pc_sets <- list()

    pc_sets$PC_1_2 <- list(pcs = c(1,2), min_dim = 2)

    if (n_pcs >= 3) {
      pc_sets$PC_1_2_3 <- list(pcs = c(1,2,3), min_dim = 3)
    }

    if (n_pcs >= 4) {
      pc_sets$PC_2_3_4 <- list(pcs = c(2,3,4), min_dim = 4)
      pc_sets$PC_3_4 <- list(pcs = c(3,4), min_dim = 4)
    }

    if(n_pcs >= 5) {
      for(i in seq(5, n_pcs, by = 1)) {
        if(i <= n_pcs) {
          # 3D plot for each group of 3
          pc_sets[[paste0("PC_", i-2, "_", i-1, "_", i)]] <-
            list(pcs = c(i-2, i-1, i), min_dim = i)

          # 2D plot for final two PCs in group
          pc_sets[[paste0("PC_", i-1, "_", i)]] <-
            list(pcs = c(i-1, i), min_dim = i)
        }
      }
    }
    return(pc_sets)
  }

  pc_sets <- generate_pc_sets(n_pcs = PCs) # Run the helper function and establish the sets

  create_plot_labels <- function(pcs, PCA_var) { # helper function to automate lollipop graphs
    n_pcs <- length(pcs)

    if (n_pcs == 2) {
      # 2D plot
      title <- sprintf("Principal Components %d-%d (%.4f%%)",
                       pcs[1], pcs[2], PCA_var[pcs[2], 3])

      axis_labels <- list(
        x = sprintf("PC %d (%.4f%%)",
                    pcs[1], PCA_var[pcs[1], 2]),
        y = sprintf("PC %d (%.4f%%)",
                    pcs[2], PCA_var[pcs[2], 2])
      )

    } else if (n_pcs == 3) {
      # 3D plot
      title <- sprintf("Principal Components %d-%d-%d (%.4f%%)",
                       pcs[1], pcs[2], pcs[3], PCA_var[pcs[3], 3])

      axis_labels <- list(
        x = sprintf("PC %d (%.4f%%)",
                    pcs[1], PCA_var[pcs[1], 2]),
        y = sprintf("PC %d (%.4f%%)",
                    pcs[2], PCA_var[pcs[2], 2]),
        z = sprintf("PC %d (%.4f%%)",
                    pcs[3], PCA_var[pcs[3], 2])
      )
    }

    return(list(title = title, axis_labels = axis_labels))
  }

#___________________________________________________________________________________________________________________

  #___________________________________________________________________________________________________________________
  if (k == 1) { # Non-landmark data (Standard PCA Analysis)

    # Initialize Lists
    PCA_list = list()        # For Score Plots (Individuals)
    lollipop_PCs = list()    # For Loading Plots (Variables)
    lollipops$PCA_group <- list()

    scores_df <- as.data.frame(Data_PCA$x)
    colnames(scores_df) <- paste0("Comp", 1:ncol(scores_df))
    scores_df$ID <- as.character(ID)

    loadings_df <- as.data.frame(Data_PCA$rotation)
    colnames(loadings_df) <- paste0("Comp", 1:ncol(loadings_df))

    loadings_df$VarName <- as.character(coord_name)

    # 3. Handle Subsetting (Grouping variables for colors)
    if (!is.null(subset)) {
      if (length(subset) == nrow(loadings_df)) {
        loadings_df$Subset <- as.factor(subset)
      } else {
        warning("Subset length does not match number of variables. Grouping ignored.")
        loadings_df$Subset <- "All Variables"
      }
    } else {
      loadings_df$Subset <- "All Variables"
    }

    #===========================================================================
    # PART A: PCA_list (Score Plots - Individuals)
    #===========================================================================

    if (class(Group) == "list") {
      PCA_group <- list()
      lollipops$PCA_group <- vector("list", length(Group))

      for (i in seq_along(Group)) {
        for (pc_name in names(pc_sets)) {
          pc_set <- pc_sets[[pc_name]]
          # Check dimensions based on available scores
          if (ncol(scores_df) >= pc_set$min_dim && PCs >= pc_set$min_dim) {

            # hullgen expects a matrix/df with specific columns.
            # We select the necessary columns and pass them.
            hull_data <- scores_df[, 1:max(pc_set$pcs)]

            PCA_group[[pc_name]] <- hullgen(
              Data_PCs = hull_data,
              select_PC = pc_set$pcs,
              Group = Group[[i]],
              color = NULL,
              ID = ID,
              PCA_var = PCA_var,
              sym = TRUE
            )
          }
        }
        lollipops$PCA_group[[i]] <- PCA_group
      }
      names(lollipops$PCA_group) <- names(Group)
    }

    for (pc_name in names(pc_sets)) {
      pc_set <- pc_sets[[pc_name]]
      pcs <- pc_set$pcs
      labels <- create_plot_labels(pcs, PCA_var)

      if (length(pcs) == 2) {
        plot <- plotly::plot_ly(data = scores_df,
                                x = as.formula(sprintf("~Comp%d", pcs[1])),
                                y = as.formula(sprintf("~Comp%d", pcs[2])),
                                type = 'scatter',
                                mode = 'markers',
                                text = ~ID,
                                marker = list(size = 9, opacity = 0.7)) %>%
          plotly::layout(title = labels$title,
                         xaxis = list(title = labels$axis_labels$x),
                         yaxis = list(title = labels$axis_labels$y))
      } else if (length(pcs) == 3) {
        plot <- plotly::plot_ly(data = scores_df,
                                x = as.formula(sprintf("~Comp%d", pcs[1])),
                                y = as.formula(sprintf("~Comp%d", pcs[2])),
                                z = as.formula(sprintf("~Comp%d", pcs[3])),
                                type = 'scatter3d',
                                mode = 'markers',
                                text = ~ID,
                                marker = list(size = 9, opacity = 0.7)) %>%
          plotly::layout(title = labels$title,
                         scene = list(xaxis = list(title = labels$axis_labels$x),
                                      yaxis = list(title = labels$axis_labels$y),
                                      zaxis = list(title = labels$axis_labels$z)))
      }
      PCA_list[[pc_name]] <- plot
    }
    lollipops$PCA_list <- PCA_list

    #===========================================================================
    # PART B: lollipop_PCs (Loading Plots - Variables)
    #===========================================================================
    for (pc_name in names(pc_sets)) {
      pc_set <- pc_sets[[pc_name]]
      pcs <- pc_set$pcs

      if (ncol(scores_df) < pc_set$min_dim || PCs < pc_set$min_dim) next

      # Initialize Plot
      p <- plotly::plot_ly()

      # Groups for Legend (based on 'subset')
      groups <- unique(loadings_df$Subset)
      colors <- if(length(groups) <= 8) RColorBrewer::brewer.pal(max(3, length(groups)), "Set2") else rainbow(length(groups))
      shapes <- c("circle", "square", "diamond", "cross", "x", "triangle-up", "star")

      for(g_idx in seq_along(groups)) {
        grp <- groups[g_idx]
        sub_dat <- loadings_df[loadings_df$Subset == grp, ]
        col <- colors[(g_idx - 1) %% length(colors) + 1]
        shp <- shapes[(g_idx - 1) %% length(shapes) + 1]

        # --- VECTOR CONSTRUCTION ---
        n_rows <- nrow(sub_dat)

        # Helper to create lines from (0,0,0) to (x,y,z)
        make_vec <- function(val_col) {
          if(is.null(val_col)) return(NULL)
          v <- numeric(n_rows * 3)
          v[seq(1, n_rows*3, 3)] <- 0          # Start at 0
          v[seq(2, n_rows*3, 3)] <- val_col    # Go to Value
          v[seq(3, n_rows*3, 3)] <- NA         # Break line
          return(v)
        }

        # 2D Logic
        if (length(pcs) == 2) {

          # Add Vectors (Lines)
          x_vals <- sub_dat[[paste0("Comp", pcs[1])]]
          y_vals <- sub_dat[[paste0("Comp", pcs[2])]]
          line_x <- make_vec(x_vals)
          line_y <- make_vec(y_vals)

          if(!is.null(line_x)) {
            p <- p %>% plotly::add_trace(
              x = line_x, y = line_y,
              type = 'scatter', mode = 'lines',
              line = list(color = col, width = 1),
              hoverinfo = "none",
              showlegend = FALSE,
              legendgroup = grp
            )
          }

          # Add Markers + Text (Variables)
          p <- p %>% plotly::add_trace(
            data = sub_dat,
            x = as.formula(sprintf("~Comp%d", pcs[1])),
            y = as.formula(sprintf("~Comp%d", pcs[2])),
            type = 'scatter', mode = 'markers+text',
            text = ~VarName, # Explicitly mapped from character column
            textposition = "top center",
            marker = list(color = col, symbol = shp, size = 10),
            name = grp,
            legendgroup = grp,
            hovertemplate = paste("<b>%{text}</b><br>Comp", pcs[1], ": %{x:.3f}<br>Comp", pcs[2], ": %{y:.3f}")
          )

          labels <- create_plot_labels(pcs, PCA_var)
          p <- p %>% plotly::layout(
            title = paste("Variable Loadings:", labels$title),
            xaxis = list(title = labels$axis_labels$x, zeroline = TRUE),
            yaxis = list(title = labels$axis_labels$y, zeroline = TRUE)
          )

          # 3D Logic
        } else if (length(pcs) == 3) {

          # Add Vectors (Lines)
          x_vals <- sub_dat[[paste0("Comp", pcs[1])]]
          y_vals <- sub_dat[[paste0("Comp", pcs[2])]]
          z_vals <- sub_dat[[paste0("Comp", pcs[3])]]
          line_x <- make_vec(x_vals)
          line_y <- make_vec(y_vals)
          line_z <- make_vec(z_vals)

          if(!is.null(line_x)) {
            p <- p %>% plotly::add_trace(
              x = line_x, y = line_y, z = line_z,
              type = 'scatter3d', mode = 'lines',
              line = list(color = col, width = 2),
              hoverinfo = "none",
              showlegend = FALSE,
              legendgroup = grp
            )
          }

          # Add Markers + Text (Variables)
          p <- p %>% plotly::add_trace(
            data = sub_dat,
            x = as.formula(sprintf("~Comp%d", pcs[1])),
            y = as.formula(sprintf("~Comp%d", pcs[2])),
            z = as.formula(sprintf("~Comp%d", pcs[3])),
            type = 'scatter3d', mode = 'markers+text',
            text = ~VarName, # Explicitly mapped from character column
            textposition = "top center",
            marker = list(color = col, symbol = shp, size = 5),
            name = grp,
            legendgroup = grp,
            hovertemplate = paste("<b>%{text}</b><br>Comp", pcs[1], ": %{x:.3f}<br>Comp", pcs[2], ": %{y:.3f}<br>Comp", pcs[3], ": %{z:.3f}")
          )

          labels <- create_plot_labels(pcs, PCA_var)
          p <- p %>% plotly::layout(
            title = paste("Variable Loadings:", labels$title),
            scene = list(
              xaxis = list(title = labels$axis_labels$x),
              yaxis = list(title = labels$axis_labels$y),
              zaxis = list(title = labels$axis_labels$z)
            )
          )
        }
      }

      lollipop_PCs[[pc_name]] <- p
    }

    # Store results in the output lists
    lollipops$lollipop_PCs <- lollipop_PCs
  }

  if (k == 2) {   # For PCA of landmark configuration with 2 dimensions
    PCA_graph = list()
    PCA_list = list()
    lollipop_data = list()

    if (class(Group) == "list") {
      PCA_group <- list()
      lollipops$PCA_group <- vector("list", length(Group))

      for (i in seq_along(Group)) {
        for (pc_name in names(pc_sets)) {

          pc_set <- pc_sets[[pc_name]]

          if (ncol(Data_PCA$x) >= pc_set$min_dim && PCs >= pc_set$min_dim) {
            PCA_group[[pc_name]] <- hullgen(
              Data_PCA$x,
              select_PC = pc_set$pcs,
              Group = Group[[i]],
              color = NULL,
              ID = ID,
              PCA_var = PCA_var,
              sym = TRUE
            )
          }
        }
        lollipops$PCA_group[[i]] <- PCA_group
      }
      names(lollipops$PCA_group) <- names(Group)
    }

    for (pc_name in names(pc_sets)) {
      pc_set <- pc_sets[[pc_name]]
      pcs <- pc_set$pcs
      data <- data.frame(Data_PCA$x)

      # Create labels
      labels <- create_plot_labels(pcs, PCA_var)

      # Create base plot
      if (length(pcs) == 2) {
        # 2D plot
        plot <- plotly::plot_ly(data = data,
                        x = as.formula(sprintf("~Comp%d", pcs[1])),
                        y = as.formula(sprintf("~Comp%d", pcs[2])),
                        type = 'scatter',
                        mode = 'markers',
                        text = ID,
                        marker = list(size = 9)) %>%
          plotly::layout(title = labels$title,
                 xaxis = list(title = labels$axis_labels$x),
                 yaxis = list(title = labels$axis_labels$y))
      } else if (length(pcs) == 3) {
        # 3D plot
        plot <- plotly::plot_ly(data = data,
                        x = as.formula(sprintf("~Comp%d", pcs[1])),
                        y = as.formula(sprintf("~Comp%d", pcs[2])),
                        z = as.formula(sprintf("~Comp%d", pcs[3])),
                        type = 'scatter3d',
                        mode = 'markers',
                        text = ID,
                        marker = list(size = 9)) %>%
          plotly::layout(title = labels$title,
                 scene = list(
                   xaxis = list(title = labels$axis_labels$x),
                   yaxis = list(title = labels$axis_labels$y),
                   zaxis = list(title = labels$axis_labels$z)
                 ))
      }

      PCA_list[[pc_name]] <- plot
    }

    lollipops$PCA_list <- PCA_list

    if (isFALSE(no.shape)) {
      # Account for PCs with landmark data that is only two-dimensional
      mean_shape = geomorph::arrayspecs(t(data.frame(Data_PCA$center)), length(Data_PCA$center)/2, 2)
      PC_shape_list = get_extreme_shapes(Data_PCA, k = 2, PCs)

      lollipops$PC_min_max_mean <- PC_shape_list

      for (i in 1:PCs) { # To wrangle the internal function in an output that plot_ly can graph
        if(is.null(subset)) {
          mean_shape <- data.frame(X = mean_shape[,1], Y = mean_shape[,2])
          pos_shape <- data.frame(X = PC_shape_list[[i+1]][,1], Y = PC_shape_list[[i+1]][,2])
          neg_shape <- data.frame(X = PC_shape_list[[i]][,1], Y = PC_shape_list[[i]][,2])

          lollipops$PC_mean_max_min[[i]] <- list(mean_shape, pos_shape, neg_shape)

          # Initialize the Plotly graph with Mean shape points
          PCA_graph <- plotly::plot_ly()
          PCA_graph <- PCA_graph %>%
            plotly::add_trace(data = mean_shape,
                      x = ~X, y = ~Y,
                      type = 'scatter', mode = 'markers', text = coord_name,
                      marker = list(size = 2, color = "black"),
                      name = 'Mean Shape')

          x_vals <- c(rbind(pos_shape$X, mean_shape$X))
          y_vals <- c(rbind(pos_shape$Y, mean_shape$Y))

          # Add a single trace for all positive shape lines
          PCA_graph <- PCA_graph %>%
            plotly::add_trace(x = x_vals, y = y_vals,
                      type = 'scatter', mode = 'lines', text = coord_name,
                      line = list(color = "blue", width = 2),
                      name = 'Positive Shape')

          x_vals <- c(rbind(neg_shape$X, mean_shape$X))
          y_vals <- c(rbind(neg_shape$Y, mean_shape$Y))

          # Add a single trace for all negative shape lines
          PCA_graph <- PCA_graph %>%
            plotly::add_trace(x = x_vals, y = y_vals,
                      type = 'scatter', mode = 'lines', text = coord_name,
                      line = list(color = "orange", width = 2),
                      name = 'Negative Shape')

          # Add a title to the plot
          PCA_graph <- PCA_graph %>%
            plotly::layout(title = paste("PCA Lollipop of Shape Changes along Principal Component", i,
                                 "(", round(PCA_var[i,2],4), ")"), scene = list(
                                   xaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                showticklabels = FALSE, title = list(text = "")),
                                   yaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                showticklabels = FALSE, title = list(text = ""))))

          # For each meaningful PC, store the lollipop graph results
          lollipops$lollipop_PCs[[i]] <- PCA_graph

        } else { # if there are subsets

          mean_shape <- data.frame(X = mean[,1,], Y = mean[,2,], subset = subset, coord_name = coord_name)
          pos_shape <- data.frame(X = PC_shape_list[[i+1]][,1,], Y = PC_shape_list[[i+1]][,2,],
                                  subset = subset, coord_name = coord_name)
          neg_shape <- data.frame(X = PC_shape_list[[i]][,1,], Y = PC_shape_list[[i]][,2,],
                                  subset = subset, coord_name = coord_name)

          lollipops$PC_mean_max_min[[i]] <- list(mean_shape, pos_shape, neg_shape)

          add_group_traces <- function(graph, data, group_name, base_color, j, PCA_var) {
            regions <- unique(data$subset)
            for (i in seq_along(regions)) {
              region_data <- filter(data, subset == regions[i])
              graph <- graph %>%
                plotly::add_trace(data = region_data,
                          x = ~X, y = ~Y,
                          type = 'scatter3d', mode = 'markers', text = ~coord_name,
                          marker = list(size = 4, color = base_color),
                          name = paste(group_name, regions[i]))
              graph <- graph %>% plotly::layout(title = paste("PCA Lollipop of Shape Changes along Principal Component", j,
                                                      "(", round(PCA_var[j,2],4), ")"), scene = list(
                                                        xaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        yaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        zaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        dragmode = "turntable"))
            }
            return(graph)
          }

          PCA_graph = plotly::plot_ly()
          # Add traces for each main group and its subgroups
          PCA_graph <- add_group_traces(PCA_graph, mean_shape, 'Mean Shape', "black", j = i, PCA_var)

          PCA_graph <- add_group_traces(PCA_graph, pos_shape, 'Positive Shape', "blue", j = i, PCA_var)

          PCA_graph <- add_group_traces(PCA_graph, neg_shape, 'Negative Shape', "orange", j = i, PCA_var)

          lollipops$lollipop_PCs[[i]] <- PCA_graph
        }
      }
    }
  }

  #___________________________________________________________________________________________________________________
  if (k == 3) { # PCA for landmarks with 3 dimensions or more
    PCA_graph = list()
    PCA_data = list()
    PCA_list = list()
    lollipop_data = list()


    if (class(Group) == "list") {
      PCA_group <- list()
      lollipops$PCA_group <- vector("list", length(Group))

      for (i in seq_along(Group)) {
        for (pc_name in names(pc_sets)) {

          pc_set <- pc_sets[[pc_name]]

          if (ncol(Data_PCA$x) >= pc_set$min_dim && PCs >= pc_set$min_dim) {
            PCA_group[[pc_name]] <- hullgen(
              Data_PCA$x,
              select_PC = pc_set$pcs,
              Group = Group[[i]],
              color = NULL,
              ID = ID,
              PCA_var = PCA_var,
              sym = TRUE
            )
          }
        }
        lollipops$PCA_group[[i]] <- PCA_group
      }
      names(lollipops$PCA_group) <- names(Group)
    }

    for (pc_name in names(pc_sets)) {
      pc_set <- pc_sets[[pc_name]]
      pcs <- pc_set$pcs
      data <- data.frame(Data_PCA$x)

      # Create labels
      labels <- create_plot_labels(pcs, PCA_var)

      # Create base plot
      if (length(pcs) == 2) {
        # 2D plot
        plot <- plotly::plot_ly(data = data,
                        x = as.formula(sprintf("~Comp%d", pcs[1])),
                        y = as.formula(sprintf("~Comp%d", pcs[2])),
                        type = 'scatter',
                        mode = 'markers',
                        text = ID,
                        marker = list(size = 9)) %>%
          plotly::layout(title = labels$title,
                 xaxis = list(title = labels$axis_labels$x),
                 yaxis = list(title = labels$axis_labels$y))
      } else if (length(pcs) == 3) {
        # 3D plot
        plot <- plotly::plot_ly(data = data,
                        x = as.formula(sprintf("~Comp%d", pcs[1])),
                        y = as.formula(sprintf("~Comp%d", pcs[2])),
                        z = as.formula(sprintf("~Comp%d", pcs[3])),
                        type = 'scatter3d',
                        mode = 'markers',
                        text = ID,
                        marker = list(size = 9)) %>%
          plotly::layout(title = labels$title,
                 scene = list(
                   xaxis = list(title = labels$axis_labels$x),
                   yaxis = list(title = labels$axis_labels$y),
                   zaxis = list(title = labels$axis_labels$z)
                 ))
      }

      PCA_list[[pc_name]] <- plot
    }

    lollipops$PCA_list <- PCA_list

    if (isFALSE(no.shape)) {

      PC_mean_max_min = list() # Object to store the shape extremes and mean shape of each meaningful PC
      mean = geomorph::arrayspecs(t(data.frame(Data_PCA$center)), (length(Data_PCA$center)/3), 3)
      PC_shape_list = get_extreme_shapes(Data_PCA, k = 3, PCs)

      for (i in 1:PCs) { # Necessary for wrangling data into a format that plot_ly can graph

        if(is.null(subset)){
          mean_shape <- data.frame(X = mean[,1,], Y = mean[,2,], Z = mean[,3,])
          pos_shape <- data.frame(X = PC_shape_list[[i+1]][,1,], Y = PC_shape_list[[i+1]][,2,],
                                  Z = PC_shape_list[[i+1]][,3,])
          neg_shape <- data.frame(X = PC_shape_list[[i]][,1,], Y = PC_shape_list[[i]][,2,], Z = PC_shape_list[[i]][,3,])

          lollipops$PC_mean_max_min[[i]] <- list(mean_shape, pos_shape, neg_shape)

          # Initialize the Plotly graph with Mean shape points

          PCA_graph <- plotly::plot_ly()

          PCA_graph <- PCA_graph %>%
            plotly::add_trace(data = mean_shape,
                      x = ~X, y = ~Y, z = ~Z,
                      type = 'scatter3d', mode = 'markers', text = coord_name,
                      marker = list(size = 4, color = "black"),
                      name = 'Mean Shape')

          PCA_graph <- PCA_graph %>%
            plotly::add_trace(data = pos_shape,
                      x = ~X, y = ~Y, z = ~Z,
                      type = 'scatter3d', mode = 'markers', text = coord_name,
                      marker = list(size = 4, color = "blue"),
                      name = 'Positive Shape')

          PCA_graph <- PCA_graph %>%
            plotly::add_trace(data = neg_shape,
                      x = ~X, y = ~Y, z = ~Z,
                      type = 'scatter3d', mode = 'markers', text = coord_name,
                      marker = list(size = 4, color = "orange"),
                      name = 'Negative Shape')

          x_pos_vals <- c(rbind(mean_shape$X, pos_shape$X))
          y_pos_vals <- c(rbind(mean_shape$Y, pos_shape$Y))
          z_pos_vals <- c(rbind(mean_shape$Z, pos_shape$Z))

          # Add each line trace for positive shape
          PCA_graph <- PCA_graph %>%
            plotly::add_trace(x = x_pos_vals, y = y_pos_vals, z = z_pos_vals,
                      type = 'scatter3d', mode = 'lines', name = 'Pos Shape Line',
                      line = list(color = "blue", width = 2))

          x_neg_vals <- c(rbind(mean_shape$X, neg_shape$X))
          y_neg_vals <- c(rbind(mean_shape$Y, neg_shape$Y))
          z_neg_vals <- c(rbind(mean_shape$Z, neg_shape$Z))


          PCA_graph <- PCA_graph %>%
            plotly::add_trace(x = x_neg_vals, y = y_neg_vals, z = z_neg_vals,
                      type = 'scatter3d', mode = 'lines', name = 'Neg Shape Line',
                      line = list(color = "orange", width = 2))

          # Layout configuration
          PCA_graph <- PCA_graph %>%
            plotly::layout(title = paste("PCA Lollipop of Shape Changes along Principal Component", i,
                                 "(", round(PCA_var[i,2],4), ")"), scene = list(
                                   xaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                showticklabels = FALSE, title = list(text = "")),
                                   yaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                showticklabels = FALSE, title = list(text = "")),
                                   zaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                showticklabels = FALSE, title = list(text = "")),
                                   dragmode = "turntable"))

          lollipops$lollipop_PCs[[i]] <- PCA_graph

        } else { #if there are subsets

          mean_shape <- data.frame(X = mean[,1,], Y = mean[,2,], Z = mean[,3,], subset = subset, coord_name = coord_name)
          pos_shape <- data.frame(X = PC_shape_list[[i+1]][,1,], Y = PC_shape_list[[i+1]][,2,],
                                  Z = PC_shape_list[[i+1]][,3,], subset = subset, coord_name = coord_name)
          neg_shape <- data.frame(X = PC_shape_list[[i]][,1,], Y = PC_shape_list[[i]][,2,], Z = PC_shape_list[[i]][,3,],
                                  subset = subset, coord_name = coord_name)

          lollipops$PC_mean_max_min[[i]] <- list(mean_shape, pos_shape, neg_shape)

          add_group_traces <- function(graph, data, group_name, base_color, j, PCA_var) {
            regions <- unique(data$subset)
            for (i in seq_along(regions)) {
              region_data <- filter(data, subset == regions[i])
              graph <- graph %>%
                plotly::add_trace(data = region_data,
                          x = ~X, y = ~Y, z = ~Z,
                          type = 'scatter3d', mode = 'markers', text = ~coord_name,
                          marker = list(size = 4, color = base_color),
                          name = paste(group_name, regions[i]))
              graph <- graph %>% plotly::layout(title = paste("PCA Lollipop of Shape Changes along Principal Component", j,
                                                      "(", round(PCA_var[j,2],4), ")"), scene = list(
                                                        xaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        yaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        zaxis = list(showgrid = FALSE, zeroline = FALSE,
                                                                     showticklabels = FALSE, title = list(text = "")),
                                                        dragmode = "turntable"))
            }
            return(graph)
          }

          PCA_graph = plotly::plot_ly()
          # Add traces for each main group and its subgroups
          PCA_graph <- add_group_traces(PCA_graph, mean_shape, 'Mean Shape', "black", j = i, PCA_var)

          PCA_graph <- add_group_traces(PCA_graph, pos_shape, 'Positive Shape', "blue", j = i, PCA_var)

          PCA_graph <- add_group_traces(PCA_graph, neg_shape, 'Negative Shape', "orange", j = i, PCA_var)

          lollipops$lollipop_PCs[[i]] <- PCA_graph
        }
      }
    }
  }
  #_________________________________________________________
  return(lollipops)  # return internal function output
} # End of internal lolligen graphing function
