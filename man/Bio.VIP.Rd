% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Bio.VIP.R
\name{Bio.VIP}
\alias{Bio.VIP}
\title{Partial Least Squares Analysis between multivariate sets of Biological Variables}
\usage{
Bio.VIP(
  Models = NULL,
  point_set = NULL,
  paired_subsets = FALSE,
  vips = TRUE,
  vip_method = "spls",
  lv_method = "mean",
  cv_type = "CV",
  covs = FALSE,
  key = NULL,
  parallel = TRUE,
  print_progress = TRUE,
  core_choice = "detect",
  ...
)
}
\arguments{
\item{Models}{Nested list object containing regression hypotheses to test. Each list element should
contain Response and Predictor data, structured as:

\itemize{
\item 'Hypothesis Test Models' # Argument Models object name
\itemize{
\item 'Symphyseal shape ~ Posterior Corpus Properties' --- 1st hypothesis model
\itemize{
\item 'Symphyseal shape ~ LM1-M2 Corpus Properties ' --- 1st hypothesis test
\itemize{
\item Symphyseal Landmarks --- Response Data within hypothesis test
\item LM1-M2 Corpus Properties --- Predictor data within hypothesis test
\item dt_parameters --- Optional data transformation parameters
}
\item 'Symphyseal shape ~ LP3-P4 Corpus Properties ' --- 2nd hypothesis test
\itemize{
\item Symphyseal Landmarks --- Response Data within hypothesis test
\item LP3-P4 Corpus Properties --- Predictor data within hypothesis test
\item dt_parameters --- Optional data transformation parameters
}
\item 'Symphyseal shape ~ RP3-P4 Corpus Properties ' --- 3rd hypothesis test
\itemize{
\item Symphyseal Landmarks --- Response Data within hypothesis test
\item RP3-P4 Corpus Properties --- Predictor data within hypothesis test
\item dt_parameters --- Optional data transformation parameters
}
\item 'Symphyseal shape ~ RM1-M2 Corpus Properties ' --- 4th hypothesis test
\itemize{
\item Symphyseal Landmarks --- Response Data within hypothesis test
\item RM1-M2 Corpus Properties --- Predictor data within hypothesis test
\item dt_parameters --- Optional data transformation parameters
}
}
\item 'Symphyseal shape ~ Posterior Corpus Properties' --- 2nd hypothesis model
\itemize{
\item 'Symphyseal shape ~ All Corpus Properties ' --- 1st hypothesis test
\itemize{
\item Symphyseal Landmarks --- Response Data within hypothesis test
\item Posterior Corpus Properties --- Predictor data within hypothesis test
\item dt_parameters --- Optional data transformation parameters
}
}
\item ..... --- 3rd hypothesis model
}
}}

\item{point_set}{Optional nested list specifying variable subsets to analyze. Structure must
match Models argument with added subset definitions:
\itemize{
\item point_set
\itemize{
\item Model_1 # Argument object name
\itemize{
\item Response               # Response list subsets (e.g., landmarks)
\itemize{
\item Subset_1 = c(1:20)    # Landmarks 1-20
\item Subset_2 = c(21:40)   # Landmarks 21-40
\item Subset_3 = c(41:60)   # Landmarks 41-60
}
\item Predictor              # Predictor subsets (e.g., data table)
\itemize{
\item Subset_1 = c(1:5)     # Variables 1-5
\item Subset_2 = c(6:10)    # Variables 6-10
\item Subset_3 = c(11:15)   # Variables 11-15
}
}
}
}}

\item{paired_subsets}{Logical value indicating whether to analyze all possible combinations
of response and predictor subsets. By default, paired_subsets is FALSE. When FALSE,
subsets are paired (Response subset 1, Predictor subset 1; Response subset 2; Predictor subset 2;...).}

\item{vips}{Logical value indicating whether to estimate and plot
variable importance in projection scores for which variables in each model's
Predictor data best explains the variation in the complete response data.}

\item{vip_method}{Character string specifying PLS method to use:
\itemize{
\item{"spls"}   {sparce PLS via \pkg{mixOmics}}
\item{"pls"}    {traditional PLS via \pkg{pls}}
\item{"pcr"}    {traditional principal component regression via \pkg{pls}}
\item{"plsr2"}  {two-block PLS via \pkg{plsdepot}}
}}

\item{lv_method}{Character specifying method for selecting important variables:
\itemize{
\item{"trim"}   {Select Predictors with VIP scores > 1 across all latent components.}
\item{"median"} {Select Predictors with VIP scores greater than the median VIP scores across all latent components.}
\item{"mean"}   {Select Predictors with VIP scores greater than the meean VIP scores across all latent components.}
}}

\item{cv_type}{Character specifying cross-validation type}

\item{covs}{Logical value indicating whether to perform covariance analysis for
shape datasets. This mode can handle 2D or 3D datasets and will provide covariation
statistics for each hypothesis in a model}

\item{key}{Optional character string for naming output directories}

\item{parallel}{Logical value indicating whether to use parallel processing}

\item{print_progress}{Logical value indicating whether to display progress bars}

\item{core_choice}{Character value specifying number of cores to use.
The following options are available:
\itemize{
\item{"detect"}       {:  total available cores - 2}
\item{"high"}         {:  28 cores}
\item{"medium-high"}  {:   20 cores}
\item{"medium"}       {:  14 cores}
\item{"medium-low"}   {:  10 cores}
\item{"low"}          {:   8 cores}
} ("detect" , "high", "medium-high", "medium", "medium-low", "low", or specific number)}
}
\value{
A list of class "Bio.VIP" containing:
\itemize{
\item{scores}          {Nested list with data tables of VIP scores for each test}
\item{plsr.results}    {PLS model results including:
\itemize{summary
\item{R2}          {Model fit statistics}
\item{Q2}          {Cross-validation prediction statistics}
\item{RMSEP}       {Root mean square error of prediction}
\item{p_value}     {cross-validated statistical significance value}
\item{reg}         {Nested list with model coefficients and loadings}
}
}
\item{Cov.All}         {Nested list with two-block PLS shape covariation test statistics
\itemize{
\item{pls2b}       {Object output from the \code{pls2B} function from \pkg{Morpho}
\itemize{
\item{lollipop.LV.1.Pred_and_Res}   {Optional \pkg{plotly} object when both data sets are shape arrays}
\item{lollipop.LV.1.Response}       {Optional \pkg{plotly} object when Response data is shape array but not Predictor}
}
}
}
}
\item{Cov.VIP}         {Nested list with two-block PLS shape covariation test statistics trimmed using VIP analysis
\itemize{
\item{pls2b}       {Object output from the \code{pls2B} function from \pkg{Morpho} with VIP trimming
\itemize{
\item{lollipop.LV.1.Pred_and_Res}   {Optional \pkg{plotly} object when both data sets are shape arrays}
\item{lollipop.LV.1.Response}       {Optional \pkg{plotly} object when Response data is shape array but not Predictor}
}
}
}
}
}
}
\description{
Bio.VIP is a function designed to investigate covariance relationships
between sets of multivariate data. This function uses a model-based hypothesis
testing structure where a \code{Models} nested list object contains hypothesis tests
which usually involve one or more covariation test sets of data. Data can be
both subsetted and transformed using the \code{DT} function (see details).
This function allows multiple data types such as geometric morphometric, genetic,
and biomechancial data sets to be compared in a partial least squares test.
Covariation tests between these sets of data within a hypothesis is ran in
parallel using a user-selected Partial Least Squares calculation. For each
covariation test within a hypothesis model, the function will generate summary
statistics along with an optional output for variable importance in projection
plots to evaluate important predictor variables.
}
\details{
Bio.VIP conducts partial least squares (PLS) analyses in parallel for each test within
a hypothesis model. The following methods in PLS are accepted:

\itemize{
\item{Sparse PLS ("spls")} {Via mixOmics package, optimal for high-dimensional,
linearly related data which requires automatic feature selection (e.g., variable
trimming) using LASSO (Least Absolute Shrinkage and Selection Operator)
based regularization parameters to include only the influential predictor
variables in predicting the response data.}
\item{Orthogonal PLS ("oscorepls")} {via pls package, optimal for
high-dimensional, linearly related data which requires automatic feature
selection using a singular value decomposition (i.e., PCA) based regularization
parameters to only include predictor variables which are orthogonally related
to the response data.}
\item{Traditional Kernel PLS ("kernelpls")} {Via pls package, optimal for
non-linear, multidimensional data.}
\item{Wide Kernel PLS ("widekernelpls")} {via pls package, optimal for
non-linear, multidimensional data with a larger variable to observation ratio.}
\item{Canonically Powered PLS ("cppls")} {via pls package, optimal for
maximizing overall correlations between linearly related, multivariate data.}
\item{Principal Correlation Regression ("svdpc")} {via pls package, optimal
for maximizing correlations between data sets that need to be subject to
multidimensionality reduction (principal component analysis).}
\item{Two-Block PLS ("plsr2")} {Via plsdepot package, optimal for analyzing
relationships between two blocks of linearly related data.}
\item{Two-Block PLS (covs = TRUE)} {via Morpho package, optimal for analyzing
relationships between two blocks of multidimensional shape data.}
}

The function sequentially evaluates each hypothesis model in the Models object
and runs, in parallel, a user-selected PLS for each test within the hypothesis
model. If point_set is not NULL, data will be subsetted prior to analysis. All
data is subjected to user-specified transformation using the \code{DT} function
parameters via the argument (...). If no \code{DT} function parameters are
provided, no data transformation will occur prior to PLS analysis.

Partial Least Squares requires a specification for the number of latent components
to explore to maximize the covariance/correlation relationships between sets
of data. For method "spls", the \code{tune.spls} function is carried out to
identify the number of latent components by maximizing the squared correlation
coefficient (R^2) and minimizing the Root Square Mean Error of Prediction (RMSEP).
Additionally, only with method "spls", an autotuning procedure is taken based
on the number of predictor and response variables in the test to identify the
best number of meaningful variables in both the predictor and response that
produces the highest squared correlation coefficient (R^2) as well as the
lowest modelerror (RMSEP). Autotuning is a feature specific to the SPLS methodology
in feature reduction, but can be turned off by setting autotune = FALSE.
Similarly, for all other methods, an internal \code{NComp} function is run to
identify the number of meaningful latent components following the same criteria
but without feature autotuning.

This function also supports an optional two-block PLS method through the
\pkg{Morpho} package particularly for analyzes of integration tests. If geometric
morphometric data is supplied in a \link{p x k x n} (landmarks, dimensions, observations)
array, the function will also store interactive .html plots using the \pkg{plotly}
package of the covariance relationships of the response data. Additionally,
summary statistics will be calculated for each hypothesis test.
The following statistics are provided:

\itemize{
\item{df}                 {List of all variables in the predictor data}
\item{PLS2B}              {Data table of the latent variable weights and correlations of the test}
\item{All RV Coefficient} {The RV integration statistic for the test based on all predictor data}
\item{All RV P-Value}     {The p-value associated with the test on all prdictor data}
\item{VIP Vars}           {List of variables after VIP selection}
\item{VIP PLS2B}          {Data table of the latent variable weights and correlations of the test after VIP trimming}
\item{VIP RV Coefficient} {The RV integration statistic for the test based on VIP trimmed predictor data}
\item{VIP RV P-Value}     {The p-value associated with the test on VIP trimmed prdictor data}
}

As each test is performed, an internal function \code{plsr_stats} is conducted
to produce cross-validated summary statistics including an overall squared (R^2)
and cross-validated (Q2) correlation coefficient as well as the Root Mean Squared
Error of Prediction (RMSEP) and a statistical significance value (p-value).

Variable importance in Bio.VIP is assessed through Variable Importance in
Projection scores (VIPs), calculated by the weight that each variable of the
predictor data which explains the most variance across the selected latent variables.
Variables can be selected using the lv_method argument based on different
thresholds (VIP > 1, median VIP, or mean VIP) across all selected latent variables.
VIP plots are subsequently generated and stored in a directory folder called
"PLS Regression - VIP Scores" with an optionally specified key argument string
to avoid data overwriting when running more than once. To stop VIP plot generation,
set vips = FALSE.

This function has a progress bar built in and can be removed by setting
print.progress = FALSE.

Parallel processing is used to maxmize computational efficiency. As such, the
number of cores available for analysis can be automatically detected by using
"detect" string in argument core_choice or as one of the options defined in the
core_choice argument.
}
\examples{
\dontrun{
# Scenario Example:
# Question: Which variables and to what degree is mandibular symphyseal shape
# influenced by the cross-sectional properties of masticatory regions of the
# posterior corpus?

# Create hypothesis model structure
Models <- list(
  'Symphyseal_Shape ~ Posterior_Corpus_Properties' = list( # This is your hypothesis model
    'Symphysis_LM1M2' = list( # This is your first hypothesis test
      'Response' = Corpus_Land[241:360,,],  # Symphysis landmarks
      'Predictor' = Biomechanics \%>\%
        filter(Region == "LM1M2") \%>\%
        select(5:93)  # Biomechanical variables,
       'dt_parameters' =  list(Res_transform = "NULL", # No data transformation. Default is "NULL"
                               Pred_transform = "NULL", # No data transformation. Default is "NULL"
                               point_set_res = NULL, # Not necessary since we will add a point_set but useful for single subset cases
                               point_set_pred = NULL
                               )
    ),
    'Symphysis_LP3P4' = list(
      'Response' = Corpus_Land[241:360,,],
      'Predictor' = Biomechanics \%>\%
        filter(Region == "LP3P4") \%>\%
        select(5:93),
      'dt_parameters' = list() # adding this is not necessary if not transforming data prior to analysis.
    ),
    'Symphysis_RP3P4' = list(
      'Response' = Corpus_Land[241:360,,],
      'Predictor' = Biomechanics \%>\%
        filter(Region == "RP3P4") \%>\%
        select(5:93)
    ),
    'Symphysis_LP3P4' = list(
      'Response' = Corpus_Land[241:360,,],
      'Predictor' = Biomechanics \%>\%
        filter(Region == "RM1M2") \%>\%
        select(5:93)
    ),
  )
)

# Define variable subsets for testing which cross-sectional properties are important in symphyseal shape
point_set <- list('Symphyseal Shape ~ Posterior_Corpus_Properties' =
                     list(
                       'Symphysis_Shape ~ LM1M2' = list(
                         'Symphysis_Shape' = list(
                              'Subset_1' = c(1:120), # symphysis has 120 total landmarks
                              'Subset_2' = c(1:120),
                              'Subset_3' = c(1:120),
                              'Subset_4' = c(1:120),
                              'Subset_5' = c(1:120)
                              ),

                         'LM1M2' = list(
                              'Dimensions' = c(5,7:12,14:19),
                              'Orientation' = c(13, 28),
                              'Cortical Thickness' = c(6, 20:22, 34:93),
                              'Bending Resistance' = c(23:27),
                              'Breaking Strength' = c(29:33)
                              )
                         ),
                       'Symphysis_Shape ~ LP3P4' = list(
                         'Symphysis_Shape' = list(
                              'Subset_1' = c(1:120), # symphysis has 120 total landmarks
                              'Subset_2' = c(1:120),
                              'Subset_3' = c(1:120),
                              'Subset_4' = c(1:120),
                              'Subset_5' = c(1:120)
                              ),

                         'LP3P4' = list(
                              'Dimensions' = c(5,7:12,14:19),
                              'Orientation' = c(13, 28),
                              'Cortical Thickness' = c(6, 20:22, 34:93),
                              'Bending Resistance' = c(23:27),
                              'Breaking Strength' = c(29:33)
                              )
                         ),
                        'Symphysis_Shape ~ RP3P4' = list(
                         'Symphysis_Shape' = list(
                              'Subset_1' = c(1:120), # symphysis has 120 total landmarks
                              'Subset_2' = c(1:120),
                              'Subset_3' = c(1:120),
                              'Subset_4' = c(1:120),
                              'Subset_5' = c(1:120)
                              ),

                         'RP3P4' = list(
                              'Dimensions' = c(5,7:12,14:19),
                              'Orientation' = c(13, 28),
                              'Cortical Thickness' = c(6, 20:22, 34:93),
                              'Bending Resistance' = c(23:27),
                              'Breaking Strength' = c(29:33)
                              )
                         ),
                        'Symphysis_Shape ~ RM1M2' = list(
                         'Symphysis_Shape' = list(
                              'Subset_1' = c(1:120), # symphysis has 120 total landmarks
                              'Subset_2' = c(1:120),
                              'Subset_3' = c(1:120),
                              'Subset_4' = c(1:120),
                              'Subset_5' = c(1:120)
                              ),

                         'RM1M2' = list(
                              'Dimensions' = c(5,7:12,14:19),
                              'Orientation' = c(13, 28),
                              'Cortical Thickness' = c(6, 20:22, 34:93),
                              'Bending Resistance' = c(23:27),
                              'Breaking Strength' = c(29:33)
                              )
                         )
                      )
                  )

# Run covariation analysis
results <- Bio.VIP(
  Models = Models, # add in hypothesis models
  point_set = point_set, # add in subsets
  paired_subsets = FALSE, # since the Response data stays the same, its unnecessary to do cross comparisons
  covs = TRUE # since we have 3D shape data, let's view the covarying shape changes by the predictor variables
) # keep defaults

# Identify the VIP scores for the first subsetted test ('Symphysis_Shape ~ LM1M2') in the first hypothesis model ('Symphysis_Shape ~ Posterior_Corpus_Properties')

results[[1]]$scores[[1]][[1]]

# Explanation
# results is the output
# [[1]] after results refers to the first hypothesis model ('Symphysis_Shape ~ Posterior_Corpus_Properties')
# $scores refers to the VIP scores
# [[1]] after $scores refers to the first test in the first hypothesis model ('Symphysis_Shape ~ LM1M2')
# [[1]] after [[1]] refers to the first subset test in the first test in the first hypothesis model ('Symphysis_Shape ~ LM1M2' -- "Corpus Dimensions")

# You can view the VIP plot generated for this test as well!
library(magick)
VIP_plot <- read.image("/PLS VIP Scores/Symphysis_Shape ~ LM1M2_Subset_1_Dimensions.png")

# View covariance results between symphyseal shape and corpus dimensions of the LM1M2 corpus region.

results[[1]]$COV.VIP[[1]][[1]]$pls2b

# View interactive plot for the first latent variable
# NOTE: all plots are stored in file directory

results[[1]]$COV.VIP[[1]][[1]]$pls2b$lollipop.LV.1.Response

# View covariance results from the excel output

view(
     read_xlsx("/PLS VIP Scores/2BPLS_Subset_1_Dimensions_Model_1.xlsx")
     )
}
}
\references{
Rohart F, Gautier B, Singh A, Lê Cao K-A (2017). "mixOmics: An R package for 'omics feature
selection and multiple data integration." PLoS Computational Biology, 13(11), e1005752.

Lê Cao K-A, Rossouw D, Robert-Granié C, Besse P (2008). "A sparse PLS for variable selection
when integrating Omics data." Statistical Applications in Genetics and Molecular Biology, 7(1), 35.

Mevik, B.H., Wehrens, R. and Liland, K.H. (2019). pls: Partial Least Squares and Principal
Component Regression. R package version 2.7-3.

Sanchez, G. (2012). plsdepot: Partial Least Squares (PLS) Data Analysis Methods.
}
\seealso{
\code{\link{AABA}} \code{\link{NComp}} \code{\link{plsr_stats}}
}
\author{
Brian Anthony Keeling
}
